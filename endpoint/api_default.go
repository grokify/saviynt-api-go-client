/*
Endpoints API

API endpoints extracted from the 'Endpoints' section of Identity Administration.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package endpoint

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// EndPointAPIService EndPointAPI service
type EndPointAPIService service

type ApiCreateDynamicAttributePostRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiCreateDynamicAttributePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDynamicAttributePostExecute(r)
}

/*
CreateDynamicAttributePost Create Dynamic Attribute

This API creates dynamic attributes in EIC.

The `Authorization` must have `Bearer` followed by `Token`.

Mandatory params:

`securitysystem`

`endpoint`

`updateuser`

`dynamicattributes` - `attributename`, `requesttype`(ACCOUNT/PROPOSED ENTITLEMENT OWNER/ENTITLEMENT OWNER ATTESTATION/ROLE/SERVICE ACCOUNT)

Optional params:

`dynamicattributes` - other dynamic attribute parameters:

- `attributetype`: Specify the attribute type based on which you want to filter and display the dynamic attributes.The various types of attribute types are: Single select from Sql Query, ENUM, Password, Boolean (True,False), String, Check Box, Date, and so on.
- `attributename`: Specify the dynamic attribute name to be used for filtering out and calling the respective attribute to be displayed.
- `Attribute Group`: Attribute Group provides you an option to group or categorize and display the dynamic attributes in the Access Requests request form.
- `Order Index`: Specify the sequence where you want to display the dynamic attributes. You can specify values such as 0,1, 2, 3 and so on. Order index with lower values is displayed first and those with higher values are displayed later.
- `attributelable`: Specify the name of the attribute, which you want to display in the Access Requests request form. You can apply the following font styling to the label:
    - `##SavBoldStart##Attribute_Name##SavBoldEnd##`
    - `##SavUnderlineStart##Attribute_Name##SavItalicEnd##`
    - `##SavUnderlineStart##Attribute_Name##UnderlineEnd##`
    - `##SavAnchorStart####SavUrlStart##https://exampleorg.com##SavUrlEnd####SavUrlTextStart##URL_Text##SavUrlTextEnd####SavAnchorEnd##`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDynamicAttributePostRequest
*/
func (a *EndPointAPIService) CreateDynamicAttributePost(ctx context.Context) ApiCreateDynamicAttributePostRequest {
	return ApiCreateDynamicAttributePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) CreateDynamicAttributePostExecute(r ApiCreateDynamicAttributePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.CreateDynamicAttributePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createDynamicAttribute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateEndpointPostRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiCreateEndpointPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateEndpointPostExecute(r)
}

/*
CreateEndpointPost Create Endpoint

This API creates an endpoint in EIC.

The `Authorization` must have a `Bearer` followed by a `Token`.

Mandatory parameters:

- `endpointname`: Enter the name of the endpoint. Provide a logical name for the endpoint that will help you to easily identify the endpoint.
- `displayName`: Enter a name for the endpoint that will be displayed in the user interface. Display Name can be different from Endpoint Name.
- `securitysystem:`Select the security system for which you want to create an endpoint. The security system encapsulates the endpoint along with other endpoints sharing the same connections, workflows, or more.
    

Optional parameters:

`description`,  
`ownerType`,  
`owner`,  
`resourceOwnerType`,  
`resourceOwner`,  
`customproperty` - N is between 1 to 30,  
`custompropertyLabel` - N is between 1 to 30,  
`accountNameRule`,  
`accessquery`,  
`enableCopyAccess`,  
`disableNewAccountRequestIfAccountExists`,  
`disableRemoveAccount`,  
`disableModifyAccount`,  
`blockInflightRequest`,  
`userAccountCorrelationRule`,  
`connectionconfig`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEndpointPostRequest
*/
func (a *EndPointAPIService) CreateEndpointPost(ctx context.Context) ApiCreateEndpointPostRequest {
	return ApiCreateEndpointPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) CreateEndpointPostExecute(r ApiCreateEndpointPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.CreateEndpointPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createEndpoint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateEntitlementTypePostRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiCreateEntitlementTypePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateEntitlementTypePostExecute(r)
}

/*
CreateEntitlementTypePost Create Entitlement Type

This API creates Entitlement Type in SSM.

The `Authorization` must have `Bearer` followed by `Token`.

Mandatory params:

`entitlementname`,
`endpointname`

Optional params:

`entitlementdescription`,
`customproperty<N>` - customproperty 1 to 5,
`workflow`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEntitlementTypePostRequest
*/
func (a *EndPointAPIService) CreateEntitlementTypePost(ctx context.Context) ApiCreateEntitlementTypePostRequest {
	return ApiCreateEntitlementTypePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) CreateEntitlementTypePostExecute(r ApiCreateEntitlementTypePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.CreateEntitlementTypePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createEntitlementType"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDynamicAttributeDeleteRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiDeleteDynamicAttributeDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDynamicAttributeDeleteExecute(r)
}

/*
DeleteDynamicAttributeDelete Delete Dynamic Attribute

This API deletes dynamic attributes in SSM.

The `Authorization` must have `Bearer` followed by `Token`.

Mandatory params:

`securitysystem`

`endpoint`

`updateuser`

`dynamicattributes` - attributename list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteDynamicAttributeDeleteRequest
*/
func (a *EndPointAPIService) DeleteDynamicAttributeDelete(ctx context.Context) ApiDeleteDynamicAttributeDeleteRequest {
	return ApiDeleteDynamicAttributeDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) DeleteDynamicAttributeDeleteExecute(r ApiDeleteDynamicAttributeDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.DeleteDynamicAttributeDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteDynamicAttribute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFetchDynamicAttributeGetRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiFetchDynamicAttributeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.FetchDynamicAttributeGetExecute(r)
}

/*
FetchDynamicAttributeGet Fetch Dynamic Attributes

This API fetches the dynamic attributes in SSM.

The `Authorization` must have `Bearer` followed by `Token`.

Optional params:

`securitysystem`

`endpoint`

`dynamicattributes`

`max`, `offset`,

`requesttype` - can be ['ACCOUNT', 'PROPOSED ENTITLEMENT OWNER', 'ENTITLEMENT OWNER ATTESTATION', 'ROLE', 'SERVICE ACCOUNT','USER'],

`loggedinuser`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchDynamicAttributeGetRequest
*/
func (a *EndPointAPIService) FetchDynamicAttributeGet(ctx context.Context) ApiFetchDynamicAttributeGetRequest {
	return ApiFetchDynamicAttributeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) FetchDynamicAttributeGetExecute(r ApiFetchDynamicAttributeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.FetchDynamicAttributeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fetchDynamicAttribute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEndpointsPostRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiGetEndpointsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEndpointsPostExecute(r)
}

/*
GetEndpointsPost Get List of Endpoints

This API returns list of Endpoints in EIC.

The `Authorization` must have `Bearer` followed by `Token`.

Optional params:  
`connectionType`,  
`endpointkey`,  
`endpointname`,  
`max`,  
`offset`,  
`filterCriteria`

**Note**: You must specify the value for `endpointkey` parameter in array. Fr example, `"endpointkey" : [5]`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEndpointsPostRequest
*/
func (a *EndPointAPIService) GetEndpointsPost(ctx context.Context) ApiGetEndpointsPostRequest {
	return ApiGetEndpointsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) GetEndpointsPostExecute(r ApiGetEndpointsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.GetEndpointsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getEndpoints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEntitlementTypesentitlementnametestEnt81GetRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiGetEntitlementTypesentitlementnametestEnt81GetRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEntitlementTypesentitlementnametestEnt81GetExecute(r)
}

/*
GetEntitlementTypesentitlementnametestEnt81Get Get List of Entitlement Types

This API returns list of Entitlement Types in SSM.

The `Authorization` must have `Bearer` followed by `Token`.

Optional params:

`entitlementname`,
`max`,
`offset`,
`endpointname`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEntitlementTypesentitlementnametestEnt81GetRequest
*/
func (a *EndPointAPIService) GetEntitlementTypesentitlementnametestEnt81Get(ctx context.Context) ApiGetEntitlementTypesentitlementnametestEnt81GetRequest {
	return ApiGetEntitlementTypesentitlementnametestEnt81GetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) GetEntitlementTypesentitlementnametestEnt81GetExecute(r ApiGetEntitlementTypesentitlementnametestEnt81GetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.GetEntitlementTypesentitlementnametestEnt81Get")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getEntitlementTypes?entitlementname=testEnt81"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDynamicAttributePutRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiUpdateDynamicAttributePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDynamicAttributePutExecute(r)
}

/*
UpdateDynamicAttributePut Update Dynamic Attribute

This API updates dynamic attributes in SSM.

The `Authorization` must have `Bearer` followed by `Token`.

Mandatory params:

`securitysystem`

`endpoint`

`updateuser`

`dynamicattributes` - `attributename`

Optional params:

- `dynamicattributes` - other attributes of dynamic attributes
- `attributetype`(BOOLEAN/NUMBER/STRING/ENUM/MULTIPLE SELECT FROM LIST/MULTIPLE SELECT FROM SQL QUERY/SINGLE SELECT FROM SQL QUERY/PASSWORD/LARGE TEXT/CHECK BOX/DATE)
- `requesttype`(ACCOUNT/PROPOSED ENTITLEMENT OWNER/ENTITLEMENT OWNER ATTESTATION/ROLE/SERVICE ACCOUNT)
- `attributelable`: Specify the name of the attribute, which you want to display in the Access Requests request form. You can apply following font styling to the label:
    - **##SavBoldStart##**_**Attribute_Name**_**##SavBoldEnd##**
    - **##SavItalicStart##**_**Attribute_Name**_**##SavItalicEnd##**
    - **##SavUnderlineStart##**_**Attribute_Name**_**##SavItalicEnd##**
    - **##SavUrlStart##**_**Attribute_Name**_**##SavUrlEnd##**
    - **##SavAnchorStart####SavUrlStart##**[<b>https://exampleorg.com##SavUrlEnd####SavUrlTextStart##</b>]()_**URL_Text**_**##SavUrlTextEnd####SavAnchorEnd##**

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateDynamicAttributePutRequest
*/
func (a *EndPointAPIService) UpdateDynamicAttributePut(ctx context.Context) ApiUpdateDynamicAttributePutRequest {
	return ApiUpdateDynamicAttributePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) UpdateDynamicAttributePutExecute(r ApiUpdateDynamicAttributePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.UpdateDynamicAttributePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/updateDynamicAttribute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateEndpointPutRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiUpdateEndpointPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateEndpointPutExecute(r)
}

/*
UpdateEndpointPut Update Endpoint

This API updates an endpoint within the Saviynt EIC.

The `Authorization` must have a `Bearer` followed by a `Token`.

Note: From Release v23.9, a new parameter **`requestableRoleType`** is introduced to update the requestable options of a Role for a particular endpoint.

Mandatory parameters:

`endpointname`  
`roleType` Supports valid case-senstive string values such as "Enabler”, “Transactional”, “EmergencyAccess”, “Enterprise”, and “Application”

Optional parameters:

`securitysystem`,  
`displayName`,  
`description`,  
`ownerType`,  
`owner`,  
`resourceOwnerType`,  
`resourceOwner`,  
`customproperty` - N is between 1 to 30,  
`custompropertyLabel` - N is between 1 to 30,  
`accountNameRule`,  
`accessquery`,  
`enableCopyAccess`,  
`disableNewAccountRequestIfAccountExists`,  
`disableRemoveAccount`,  
`disableModifyAccount`,  
`blockInflightRequest`,  
`userAccountCorrelationRule`,  
`createEntTaskforRemoveAcc`,  
`connectionconfig requestableRoleType requestOption` - Supports valid case-senstive string values such as “None”, “DropDownSingle”, “Table”, and “TableOnlyAdd”  
`required` - Supports valid boolean values are true and false`requestedQuery/selectedQuery` Supports string values in double quotes  
`showOn` - Supports valid case-sensitive string values such as "All", "ShowOnApplicationRequest", and "ShowOnServiceAccountRequest". specify the value to display the roles on Application Requests, Service Account Requests, or both. This parameter is available from the Release v24.6 onwards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateEndpointPutRequest
*/
func (a *EndPointAPIService) UpdateEndpointPut(ctx context.Context) ApiUpdateEndpointPutRequest {
	return ApiUpdateEndpointPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) UpdateEndpointPutExecute(r ApiUpdateEndpointPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.UpdateEndpointPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/updateEndpoint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateEntitlementTypePutRequest struct {
	ctx context.Context
	ApiService *EndPointAPIService
}

func (r ApiUpdateEntitlementTypePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateEntitlementTypePutExecute(r)
}

/*
UpdateEntitlementTypePut Update Entitlement Type

This API updates Entitlement Type in SSM.

The `Authorization` must have `Bearer` followed by `Token`.

Mandatory params:
	`entitlementname`,
	`endpointname`,
	
Optional params:
	`entitlementdescription`,
	`workflow`,
	`customproperty<N>`,
	`availableQueryServiceAccount`,
	`selectedQueryServiceAccount`, 
	`arsRequestableEntitlementQuery`, 
	`arsSelectedEntitlementQuery` , 
	`createTaskAction` - it can be one value or list of values. The values can be ["noAction","removeTaskForExistingEntitlements", "enableRollback"],
	`requestDatesConfJson` , 
	`startDateInRevokeRequest` , 
	`startEndDateInRequest` ,
	`allowRemoveAllEntitlementInRequest` , 
	`orderindex` , 
	`requiredinrequest` ,
	`hiearchyrequired` , 
	`requestoption`
	
	
`requestoption` param values can be - 
SHOW_BUT_NOTREUESTABLESINGLE/ 
SHOW_BUT_NOTREUESTABLEMULTIPLE/ 
NONE/ 
SINGLE/ 
MULTIPLE/ 
TABLE/ 
FREEFORMTEXT/ 
TABLENOREMOVE/ 
RADIOBUTN/ 
CHECKBOXN/ 
READONLYTABLE/ 
NONE_BUT_CREATETASK

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateEntitlementTypePutRequest
*/
func (a *EndPointAPIService) UpdateEntitlementTypePut(ctx context.Context) ApiUpdateEntitlementTypePutRequest {
	return ApiUpdateEntitlementTypePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndPointAPIService) UpdateEntitlementTypePutExecute(r ApiUpdateEntitlementTypePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndPointAPIService.UpdateEntitlementTypePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/updateEntitlementType"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
